export async function {{name}}(input: any): Promise<any> {
  {{#if operation.serverUrl}}
  // Use per-operation server URL (operation-level or path-level)
  const baseUrl = "{{operation.serverUrl}}";
  {{else}}
  // Fall back to global API_BASE_URL
  const baseUrl = process.env.API_BASE_URL;
  if (!baseUrl) {
    throw new Error("API_BASE_URL env var is required");
  }
  {{/if}}

  // Build URL with path params
  let path = "{{operation.path}}";
  {{#each pathParams}}
  if (input["{{this}}"] === undefined) {
    throw new Error("Missing required path parameter: {{this}}");
  }
  path = path.replace("{ {{this}} }".replace(/ /g, ""), encodeURIComponent(String(input["{{this}}"])));
  {{/each}}

  // Construct full URL: combine baseUrl with operation path
  // If baseUrl has a path, we need to handle it properly
  const baseUrlObj = new URL(baseUrl);
  const fullPath = baseUrlObj.pathname + (baseUrlObj.pathname.endsWith("/") ? "" : "/") + path.replace(/^\//, "");
  const url = new URL(fullPath, baseUrlObj.origin);

  // Add query params
  {{#each queryParams}}
  if (input["{{this}}"] !== undefined) {
    if (Array.isArray(input["{{this}}"])) {
      // Handle array parameters with [] notation (e.g., expand[]=value1&expand[]=value2)
      if (input["{{this}}"].length > 0) {
        for (const item of input["{{this}}"]) {
          url.searchParams.append("{{this}}[]", String(item));
        }
      }
      // Empty arrays are skipped - don't add parameter
    } else {
      url.searchParams.set("{{this}}", String(input["{{this}}"]));
    }
  }
  {{/each}}

  const init: any = {
    method: "{{method}}".toUpperCase(),
    headers: {
      "Content-Type": "application/json",
      "User-Agent": process.env.USER_AGENT || "{{serviceName}}-mcp/1.0.0",
    },
  };

  {{#if authConfig}}
  {{#if (eq authConfig.type "apiKey")}}
  // Add API key from environment variable if not already provided as a query parameter
  // Check if API_KEY (or the configured header name) is already in the URL
  if (!url.searchParams.has("{{authConfig.headerName}}") && !url.searchParams.has("API_KEY")) {
    const apiKey = process.env["{{authConfig.envVar}}"];
    if (apiKey) {
      // Try API_KEY first (common for AirNow), then fall back to headerName
      url.searchParams.set("API_KEY", apiKey);
    }
  }
  {{else}}
  const token = process.env["{{authConfig.envVar}}"];
  if (token) {
    {{#if (eq authConfig.type "bearer")}}
    init.headers["{{authConfig.headerName}}"] = `Bearer ${token}`;
    {{/if}}
  }
  {{/if}}
  {{/if}}

  {{#if hasBody}}
  const body: any = {};
  {{#each bodyFields}}
  if (input["{{this}}"] !== undefined) {
    body["{{this}}"] = input["{{this}}"];
  }
  {{/each}}

  init.body = JSON.stringify(body);
  {{/if}}

  const res = await fetch(url.toString(), init);
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`HTTP {{method}} {{operation.path}} failed: ${res.status} ${res.statusText} - ${text}`);
  }

  const contentType = res.headers.get("content-type") || "";
  if (contentType.includes("application/json") || contentType.includes("application/geo+json")) {
    return res.json();
  }
  return res.text();
}

