import { createInterface } from "readline";
import { tools } from "./tools";
import * as fs from "fs";
import * as path from "path";

// Load schema.json from project root (one level up from dist/)
const schemaPath = path.join(__dirname, "..", "schema.json");
const schema = JSON.parse(fs.readFileSync(schemaPath, "utf8"));

interface JsonRpcRequest {
  jsonrpc: "2.0";
  id?: string | number | null;
  method: string;
  params?: any;
}

interface JsonRpcResponse {
  jsonrpc: "2.0";
  id?: string | number | null;
  result?: any;
  error?: { code: number; message: string; data?: any };
}

const rl = createInterface({
  input: process.stdin,
  output: process.stdout,
  terminal: false,
});

function sendResponse(res: JsonRpcResponse) {
  const line = JSON.stringify(res);
  process.stdout.write(line + "\n");
}

async function handleRequest(req: JsonRpcRequest) {
  // Ensure id is always present (use null if not provided, but never undefined)
  const responseId = req.id !== undefined ? req.id : null;

  // Handle initialize
  if (req.method === "initialize") {
    sendResponse({
      jsonrpc: "2.0",
      id: responseId,
      result: {
        protocolVersion: "2024-11-05",
        capabilities: {
          tools: {}
        },
        serverInfo: {
          name: "{{serviceName}}-mcp",
          version: "1.0.0"
        }
      }
    });
    return;
  }

  // Handle tools/list
  if (req.method === "tools/list") {
    const toolList = schema.tools.map((tool: any) => ({
      name: tool.name,
      description: tool.description,
      inputSchema: tool.input_schema
    }));
    sendResponse({
      jsonrpc: "2.0",
      id: responseId,
      result: {
        tools: toolList
      }
    });
    return;
  }

  // Handle tools/execute and tools/call (both are aliases for tool execution)
  if (req.method === "tools/execute" || req.method === "tools/call") {
    const name = req.params?.name;
    const args = req.params?.arguments ?? {};

    const tool = tools[name];
    if (!tool) {
      // Convert error to success response with error content (Claude Desktop compatibility)
      sendResponse({
        jsonrpc: "2.0",
        id: responseId,
        result: {
          content: [
            {
              type: "text",
              text: JSON.stringify({ error: `Unknown tool: ${name}` })
            }
          ],
          isError: true
        }
      });
      return;
    }

    try {
      const result = await tool(args);
      sendResponse({
        jsonrpc: "2.0",
        id: responseId,
        result: {
          content: [
            {
              type: "text",
              text: JSON.stringify(result)
            }
          ],
          isError: false
        }
      });
    } catch (err: any) {
      // Convert error to success response with error content (Claude Desktop compatibility)
      sendResponse({
        jsonrpc: "2.0",
        id: responseId,
        result: {
          content: [
            {
              type: "text",
              text: JSON.stringify({ 
                error: err?.message || "Tool execution error",
                stack: err?.stack 
              })
            }
          ],
          isError: true
        }
      });
    }
    return;
  }

  // Unknown method - convert to success response with error content (Claude Desktop compatibility)
  if (responseId !== null && responseId !== undefined) {
    sendResponse({
      jsonrpc: "2.0",
      id: responseId,
      result: {
        content: [
          {
            type: "text",
            text: JSON.stringify({ error: `Method not found: ${req.method}` })
          }
        ],
        isError: true
      }
    });
  }
}

rl.on("line", (line) => {
  line = line.trim();
  if (!line) return;
  let req: JsonRpcRequest;
  try {
    req = JSON.parse(line);
  } catch (e) {
    // For parse errors, we can't determine the id, so don't send a response
    // JSON-RPC 2.0 spec says parse errors should not have an id
    return;
  }
  void handleRequest(req);
});

console.error("{{serviceName}} MCP server ready on stdin/stdout");



